import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-AUZ3RYOM.js";

// node_modules/@fal-ai/client/src/middleware.js
var require_middleware = __commonJS({
  "node_modules/@fal-ai/client/src/middleware.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TARGET_URL_HEADER = void 0;
    exports.withMiddleware = withMiddleware;
    exports.withProxy = withProxy;
    function withMiddleware(...middlewares) {
      const isDefined = (middleware) => typeof middleware === "function";
      return (config) => __awaiter(this, void 0, void 0, function* () {
        let currentConfig = Object.assign({}, config);
        for (const middleware of middlewares.filter(isDefined)) {
          currentConfig = yield middleware(currentConfig);
        }
        return currentConfig;
      });
    }
    exports.TARGET_URL_HEADER = "x-fal-target-url";
    function withProxy(config) {
      const passthrough = (requestConfig) => Promise.resolve(requestConfig);
      if (typeof window === "undefined") {
        return passthrough;
      }
      return (requestConfig) => requestConfig.headers && exports.TARGET_URL_HEADER in requestConfig ? passthrough(requestConfig) : Promise.resolve(Object.assign(Object.assign({}, requestConfig), { url: config.targetUrl, headers: Object.assign(Object.assign({}, requestConfig.headers || {}), { [exports.TARGET_URL_HEADER]: requestConfig.url }) }));
    }
  }
});

// node_modules/@fal-ai/client/src/response.js
var require_response = __commonJS({
  "node_modules/@fal-ai/client/src/response.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValidationError = exports.ApiError = void 0;
    exports.defaultResponseHandler = defaultResponseHandler;
    exports.resultResponseHandler = resultResponseHandler;
    var REQUEST_ID_HEADER = "x-fal-request-id";
    var ApiError = class extends Error {
      constructor({ message, status, body }) {
        super(message);
        this.name = "ApiError";
        this.status = status;
        this.body = body;
      }
    };
    exports.ApiError = ApiError;
    var ValidationError = class extends ApiError {
      constructor(args) {
        super(args);
        this.name = "ValidationError";
      }
      get fieldErrors() {
        if (typeof this.body.detail === "string") {
          return [
            {
              loc: ["body"],
              msg: this.body.detail,
              type: "value_error"
            }
          ];
        }
        return this.body.detail || [];
      }
      getFieldErrors(field) {
        return this.fieldErrors.filter((error) => error.loc[error.loc.length - 1] === field);
      }
    };
    exports.ValidationError = ValidationError;
    function defaultResponseHandler(response) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const { status, statusText } = response;
        const contentType = (_a = response.headers.get("Content-Type")) !== null && _a !== void 0 ? _a : "";
        if (!response.ok) {
          if (contentType.includes("application/json")) {
            const body = yield response.json();
            const ErrorType = status === 422 ? ValidationError : ApiError;
            throw new ErrorType({
              message: body.message || statusText,
              status,
              body
            });
          }
          throw new ApiError({ message: `HTTP ${status}: ${statusText}`, status });
        }
        if (contentType.includes("application/json")) {
          return response.json();
        }
        if (contentType.includes("text/html")) {
          return response.text();
        }
        if (contentType.includes("application/octet-stream")) {
          return response.arrayBuffer();
        }
        return response.text();
      });
    }
    function resultResponseHandler(response) {
      return __awaiter(this, void 0, void 0, function* () {
        const data = yield defaultResponseHandler(response);
        return {
          data,
          requestId: response.headers.get(REQUEST_ID_HEADER) || ""
        };
      });
    }
  }
});

// node_modules/@fal-ai/client/package.json
var require_package = __commonJS({
  "node_modules/@fal-ai/client/package.json"(exports, module) {
    module.exports = {
      name: "@fal-ai/client",
      description: "The fal.ai client for JavaScript and TypeScript",
      version: "1.3.0",
      license: "MIT",
      repository: {
        type: "git",
        url: "https://github.com/fal-ai/fal-js.git",
        directory: "libs/client"
      },
      keywords: [
        "fal",
        "client",
        "ai",
        "ml",
        "typescript"
      ],
      exports: {
        ".": "./src/index.js",
        "./endpoints": "./src/types/endpoints.js"
      },
      typesVersions: {
        "*": {
          endpoints: [
            "src/types/endpoints.d.ts"
          ]
        }
      },
      main: "./src/index.js",
      types: "./src/index.d.ts",
      dependencies: {
        "@msgpack/msgpack": "^3.0.0-beta2",
        "eventsource-parser": "^1.1.2",
        robot3: "^0.4.1"
      },
      engines: {
        node: ">=18.0.0"
      },
      type: "commonjs"
    };
  }
});

// node_modules/@fal-ai/client/src/runtime.js
var require_runtime = __commonJS({
  "node_modules/@fal-ai/client/src/runtime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = isBrowser;
    exports.getUserAgent = getUserAgent;
    function isBrowser() {
      return typeof window !== "undefined" && typeof window.document !== "undefined";
    }
    var memoizedUserAgent = null;
    function getUserAgent() {
      if (memoizedUserAgent !== null) {
        return memoizedUserAgent;
      }
      const packageInfo = require_package();
      memoizedUserAgent = `${packageInfo.name}/${packageInfo.version}`;
      return memoizedUserAgent;
    }
  }
});

// node_modules/@fal-ai/client/src/config.js
var require_config = __commonJS({
  "node_modules/@fal-ai/client/src/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.credentialsFromEnv = void 0;
    exports.resolveDefaultFetch = resolveDefaultFetch;
    exports.createConfig = createConfig;
    exports.getRestApiUrl = getRestApiUrl;
    var middleware_1 = require_middleware();
    var response_1 = require_response();
    var runtime_1 = require_runtime();
    function resolveDefaultFetch() {
      if (typeof fetch === "undefined") {
        throw new Error("Your environment does not support fetch. Please provide your own fetch implementation.");
      }
      return fetch;
    }
    function hasEnvVariables() {
      return typeof process !== "undefined" && process.env && (typeof process.env.FAL_KEY !== "undefined" || typeof process.env.FAL_KEY_ID !== "undefined" && typeof process.env.FAL_KEY_SECRET !== "undefined");
    }
    var credentialsFromEnv = () => {
      if (!hasEnvVariables()) {
        return void 0;
      }
      if (typeof process.env.FAL_KEY !== "undefined") {
        return process.env.FAL_KEY;
      }
      return process.env.FAL_KEY_ID ? `${process.env.FAL_KEY_ID}:${process.env.FAL_KEY_SECRET}` : void 0;
    };
    exports.credentialsFromEnv = credentialsFromEnv;
    var DEFAULT_CONFIG = {
      credentials: exports.credentialsFromEnv,
      suppressLocalCredentialsWarning: false,
      requestMiddleware: (request) => Promise.resolve(request),
      responseHandler: response_1.defaultResponseHandler
    };
    function createConfig(config) {
      var _a;
      let configuration = Object.assign(Object.assign(Object.assign({}, DEFAULT_CONFIG), config), { fetch: (_a = config.fetch) !== null && _a !== void 0 ? _a : resolveDefaultFetch() });
      if (config.proxyUrl) {
        configuration = Object.assign(Object.assign({}, configuration), { requestMiddleware: (0, middleware_1.withMiddleware)(configuration.requestMiddleware, (0, middleware_1.withProxy)({ targetUrl: config.proxyUrl })) });
      }
      const { credentials: resolveCredentials, suppressLocalCredentialsWarning } = configuration;
      const credentials = typeof resolveCredentials === "function" ? resolveCredentials() : resolveCredentials;
      if ((0, runtime_1.isBrowser)() && credentials && !suppressLocalCredentialsWarning) {
        console.warn("The fal credentials are exposed in the browser's environment. That's not recommended for production use cases.");
      }
      return configuration;
    }
    function getRestApiUrl() {
      return "https://rest.alpha.fal.ai";
    }
  }
});

// node_modules/@fal-ai/client/src/utils.js
var require_utils = __commonJS({
  "node_modules/@fal-ai/client/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ensureEndpointIdFormat = ensureEndpointIdFormat;
    exports.parseEndpointId = parseEndpointId;
    exports.isValidUrl = isValidUrl;
    exports.throttle = throttle;
    exports.isReact = isReact;
    exports.isPlainObject = isPlainObject;
    function ensureEndpointIdFormat(id) {
      const parts = id.split("/");
      if (parts.length > 1) {
        return id;
      }
      const [, appOwner, appId] = /^([0-9]+)-([a-zA-Z0-9-]+)$/.exec(id) || [];
      if (appOwner && appId) {
        return `${appOwner}/${appId}`;
      }
      throw new Error(`Invalid app id: ${id}. Must be in the format <appOwner>/<appId>`);
    }
    var ENDPOINT_NAMESPACES = ["workflows", "comfy"];
    function parseEndpointId(id) {
      const normalizedId = ensureEndpointIdFormat(id);
      const parts = normalizedId.split("/");
      if (ENDPOINT_NAMESPACES.includes(parts[0])) {
        return {
          owner: parts[1],
          alias: parts[2],
          path: parts.slice(3).join("/") || void 0,
          namespace: parts[0]
        };
      }
      return {
        owner: parts[0],
        alias: parts[1],
        path: parts.slice(2).join("/") || void 0
      };
    }
    function isValidUrl(url) {
      try {
        const { host } = new URL(url);
        return /(fal\.(ai|run))$/.test(host);
      } catch (_) {
        return false;
      }
    }
    function throttle(func, limit, leading = false) {
      let lastFunc;
      let lastRan;
      return (...args) => {
        if (!lastRan && leading) {
          func(...args);
          lastRan = Date.now();
        } else {
          if (lastFunc) {
            clearTimeout(lastFunc);
          }
          lastFunc = setTimeout(() => {
            if (Date.now() - lastRan >= limit) {
              func(...args);
              lastRan = Date.now();
            }
          }, limit - (Date.now() - lastRan));
        }
      };
    }
    var isRunningInReact;
    function isReact() {
      if (isRunningInReact === void 0) {
        const stack = new Error().stack;
        isRunningInReact = !!stack && (stack.includes("node_modules/react-dom/") || stack.includes("node_modules/next/"));
      }
      return isRunningInReact;
    }
    function isPlainObject(value) {
      return !!value && Object.getPrototypeOf(value) === Object.prototype;
    }
  }
});

// node_modules/@fal-ai/client/src/request.js
var require_request = __commonJS({
  "node_modules/@fal-ai/client/src/request.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dispatchRequest = dispatchRequest;
    exports.buildUrl = buildUrl;
    var runtime_1 = require_runtime();
    var utils_1 = require_utils();
    var isCloudflareWorkers = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.userAgent) === "Cloudflare-Workers";
    function dispatchRequest(params) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        const { targetUrl, input, config, options = {} } = params;
        const { credentials: credentialsValue, requestMiddleware, responseHandler, fetch: fetch2 } = config;
        const userAgent = (0, runtime_1.isBrowser)() ? {} : { "User-Agent": (0, runtime_1.getUserAgent)() };
        const credentials = typeof credentialsValue === "function" ? credentialsValue() : credentialsValue;
        const { method, url, headers } = yield requestMiddleware({
          method: ((_b = (_a = params.method) !== null && _a !== void 0 ? _a : options.method) !== null && _b !== void 0 ? _b : "post").toUpperCase(),
          url: targetUrl,
          headers: params.headers
        });
        const authHeader = credentials ? { Authorization: `Key ${credentials}` } : {};
        const requestHeaders = Object.assign(Object.assign(Object.assign(Object.assign({}, authHeader), { Accept: "application/json", "Content-Type": "application/json" }), userAgent), headers !== null && headers !== void 0 ? headers : {});
        const { responseHandler: customResponseHandler } = options, requestInit = __rest(options, ["responseHandler"]);
        const response = yield fetch2(url, Object.assign(Object.assign(Object.assign(Object.assign({}, requestInit), { method, headers: Object.assign(Object.assign({}, requestHeaders), (_c = requestInit.headers) !== null && _c !== void 0 ? _c : {}) }), !isCloudflareWorkers && { mode: "cors" }), { signal: options.signal, body: method.toLowerCase() !== "get" && input ? JSON.stringify(input) : void 0 }));
        const handleResponse = customResponseHandler !== null && customResponseHandler !== void 0 ? customResponseHandler : responseHandler;
        return yield handleResponse(response);
      });
    }
    function buildUrl(id, options = {}) {
      var _a, _b;
      const method = ((_a = options.method) !== null && _a !== void 0 ? _a : "post").toLowerCase();
      const path = ((_b = options.path) !== null && _b !== void 0 ? _b : "").replace(/^\//, "").replace(/\/{2,}/, "/");
      const input = options.input;
      const params = Object.assign(Object.assign({}, options.query || {}), method === "get" ? input : {});
      const queryParams = Object.keys(params).length > 0 ? `?${new URLSearchParams(params).toString()}` : "";
      if ((0, utils_1.isValidUrl)(id)) {
        const url2 = id.endsWith("/") ? id : `${id}/`;
        return `${url2}${path}${queryParams}`;
      }
      const appId = (0, utils_1.ensureEndpointIdFormat)(id);
      const subdomain = options.subdomain ? `${options.subdomain}.` : "";
      const url = `https://${subdomain}fal.run/${appId}/${path}`;
      return `${url.replace(/\/$/, "")}${queryParams}`;
    }
  }
});

// node_modules/eventsource-parser/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/eventsource-parser/dist/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function createParser(onParse) {
      let isFirstChunk;
      let buffer;
      let startingPosition;
      let startingFieldLength;
      let eventId;
      let eventName;
      let data;
      reset();
      return {
        feed,
        reset
      };
      function reset() {
        isFirstChunk = true;
        buffer = "";
        startingPosition = 0;
        startingFieldLength = -1;
        eventId = void 0;
        eventName = void 0;
        data = "";
      }
      function feed(chunk) {
        buffer = buffer ? buffer + chunk : chunk;
        if (isFirstChunk && hasBom(buffer)) {
          buffer = buffer.slice(BOM.length);
        }
        isFirstChunk = false;
        const length = buffer.length;
        let position = 0;
        let discardTrailingNewline = false;
        while (position < length) {
          if (discardTrailingNewline) {
            if (buffer[position] === "\n") {
              ++position;
            }
            discardTrailingNewline = false;
          }
          let lineLength = -1;
          let fieldLength = startingFieldLength;
          let character;
          for (let index = startingPosition; lineLength < 0 && index < length; ++index) {
            character = buffer[index];
            if (character === ":" && fieldLength < 0) {
              fieldLength = index - position;
            } else if (character === "\r") {
              discardTrailingNewline = true;
              lineLength = index - position;
            } else if (character === "\n") {
              lineLength = index - position;
            }
          }
          if (lineLength < 0) {
            startingPosition = length - position;
            startingFieldLength = fieldLength;
            break;
          } else {
            startingPosition = 0;
            startingFieldLength = -1;
          }
          parseEventStreamLine(buffer, position, fieldLength, lineLength);
          position += lineLength + 1;
        }
        if (position === length) {
          buffer = "";
        } else if (position > 0) {
          buffer = buffer.slice(position);
        }
      }
      function parseEventStreamLine(lineBuffer, index, fieldLength, lineLength) {
        if (lineLength === 0) {
          if (data.length > 0) {
            onParse({
              type: "event",
              id: eventId,
              event: eventName || void 0,
              data: data.slice(0, -1)
              // remove trailing newline
            });
            data = "";
            eventId = void 0;
          }
          eventName = void 0;
          return;
        }
        const noValue = fieldLength < 0;
        const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength));
        let step = 0;
        if (noValue) {
          step = lineLength;
        } else if (lineBuffer[index + fieldLength + 1] === " ") {
          step = fieldLength + 2;
        } else {
          step = fieldLength + 1;
        }
        const position = index + step;
        const valueLength = lineLength - step;
        const value = lineBuffer.slice(position, position + valueLength).toString();
        if (field === "data") {
          data += value ? "".concat(value, "\n") : "\n";
        } else if (field === "event") {
          eventName = value;
        } else if (field === "id" && !value.includes("\0")) {
          eventId = value;
        } else if (field === "retry") {
          const retry = parseInt(value, 10);
          if (!Number.isNaN(retry)) {
            onParse({
              type: "reconnect-interval",
              value: retry
            });
          }
        }
      }
    }
    var BOM = [239, 187, 191];
    function hasBom(buffer) {
      return BOM.every((charCode, index) => buffer.charCodeAt(index) === charCode);
    }
    exports.createParser = createParser;
  }
});

// node_modules/@fal-ai/client/src/auth.js
var require_auth = __commonJS({
  "node_modules/@fal-ai/client/src/auth.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TOKEN_EXPIRATION_SECONDS = void 0;
    exports.getTemporaryAuthToken = getTemporaryAuthToken;
    var config_1 = require_config();
    var request_1 = require_request();
    var utils_1 = require_utils();
    exports.TOKEN_EXPIRATION_SECONDS = 120;
    function getTemporaryAuthToken(app, config) {
      return __awaiter(this, void 0, void 0, function* () {
        const appId = (0, utils_1.parseEndpointId)(app);
        const token = yield (0, request_1.dispatchRequest)({
          method: "POST",
          targetUrl: `${(0, config_1.getRestApiUrl)()}/tokens/`,
          config,
          input: {
            allowed_apps: [appId.alias],
            token_expiration: exports.TOKEN_EXPIRATION_SECONDS
          }
        });
        if (typeof token !== "string" && token["detail"]) {
          return token["detail"];
        }
        return token;
      });
    }
  }
});

// node_modules/@fal-ai/client/src/streaming.js
var require_streaming = __commonJS({
  "node_modules/@fal-ai/client/src/streaming.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __await = exports && exports.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FalStream = void 0;
    exports.createStreamingClient = createStreamingClient;
    var eventsource_parser_1 = require_dist();
    var auth_1 = require_auth();
    var request_1 = require_request();
    var response_1 = require_response();
    var CONTENT_TYPE_EVENT_STREAM = "text/event-stream";
    var EVENT_STREAM_TIMEOUT = 15 * 1e3;
    var FalStream = class {
      constructor(endpointId, config, options) {
        var _a;
        this.listeners = /* @__PURE__ */ new Map();
        this.buffer = [];
        this.currentData = void 0;
        this.lastEventTimestamp = 0;
        this.streamClosed = false;
        this.abortController = new AbortController();
        this.start = () => __awaiter(this, void 0, void 0, function* () {
          var _a2, _b;
          const { endpointId: endpointId2, options: options2 } = this;
          const { input, method = "post", connectionMode = "server" } = options2;
          try {
            if (connectionMode === "client") {
              const token = yield (0, auth_1.getTemporaryAuthToken)(endpointId2, this.config);
              const { fetch: fetch2 } = this.config;
              const parsedUrl = new URL(this.url);
              parsedUrl.searchParams.set("fal_jwt_token", token);
              const response = yield fetch2(parsedUrl.toString(), {
                method: method.toUpperCase(),
                headers: {
                  accept: (_a2 = options2.accept) !== null && _a2 !== void 0 ? _a2 : CONTENT_TYPE_EVENT_STREAM,
                  "content-type": "application/json"
                },
                body: input && method !== "get" ? JSON.stringify(input) : void 0,
                signal: this.abortController.signal
              });
              return yield this.handleResponse(response);
            }
            return yield (0, request_1.dispatchRequest)({
              method: method.toUpperCase(),
              targetUrl: this.url,
              input,
              config: this.config,
              options: {
                headers: {
                  accept: (_b = options2.accept) !== null && _b !== void 0 ? _b : CONTENT_TYPE_EVENT_STREAM
                },
                responseHandler: this.handleResponse,
                signal: this.abortController.signal
              }
            });
          } catch (error) {
            this.handleError(error);
          }
        });
        this.handleResponse = (response) => __awaiter(this, void 0, void 0, function* () {
          var _a2, _b;
          if (!response.ok) {
            try {
              yield (0, response_1.defaultResponseHandler)(response);
            } catch (error) {
              this.emit("error", error);
            }
            return;
          }
          const body = response.body;
          if (!body) {
            this.emit("error", new response_1.ApiError({
              message: "Response body is empty.",
              status: 400,
              body: void 0
            }));
            return;
          }
          const isEventStream = ((_a2 = response.headers.get("content-type")) !== null && _a2 !== void 0 ? _a2 : "").startsWith(CONTENT_TYPE_EVENT_STREAM);
          if (!isEventStream) {
            const reader2 = body.getReader();
            const emitRawChunk = () => {
              reader2.read().then(({ done, value }) => {
                if (done) {
                  this.emit("done", this.currentData);
                  return;
                }
                this.currentData = value;
                this.emit("data", value);
                emitRawChunk();
              });
            };
            emitRawChunk();
            return;
          }
          const decoder = new TextDecoder("utf-8");
          const reader = response.body.getReader();
          const parser = (0, eventsource_parser_1.createParser)((event) => {
            if (event.type === "event") {
              const data = event.data;
              try {
                const parsedData = JSON.parse(data);
                this.buffer.push(parsedData);
                this.currentData = parsedData;
                this.emit("data", parsedData);
                this.emit("message", parsedData);
              } catch (e) {
                this.emit("error", e);
              }
            }
          });
          const timeout = (_b = this.options.timeout) !== null && _b !== void 0 ? _b : EVENT_STREAM_TIMEOUT;
          const readPartialResponse = () => __awaiter(this, void 0, void 0, function* () {
            const { value, done } = yield reader.read();
            this.lastEventTimestamp = Date.now();
            parser.feed(decoder.decode(value));
            if (Date.now() - this.lastEventTimestamp > timeout) {
              this.emit("error", new response_1.ApiError({
                message: `Event stream timed out after ${(timeout / 1e3).toFixed(0)} seconds with no messages.`,
                status: 408
              }));
            }
            if (!done) {
              readPartialResponse().catch(this.handleError);
            } else {
              this.emit("done", this.currentData);
            }
          });
          readPartialResponse().catch(this.handleError);
          return;
        });
        this.handleError = (error) => {
          var _a2;
          if (error.name === "AbortError" || this.signal.aborted) {
            return;
          }
          const apiError = error instanceof response_1.ApiError ? error : new response_1.ApiError({
            message: (_a2 = error.message) !== null && _a2 !== void 0 ? _a2 : "An unknown error occurred",
            status: 500
          });
          this.emit("error", apiError);
          return;
        };
        this.on = (type, listener) => {
          var _a2;
          if (!this.listeners.has(type)) {
            this.listeners.set(type, []);
          }
          (_a2 = this.listeners.get(type)) === null || _a2 === void 0 ? void 0 : _a2.push(listener);
        };
        this.emit = (type, event) => {
          const listeners = this.listeners.get(type) || [];
          for (const listener of listeners) {
            listener(event);
          }
        };
        this.done = () => __awaiter(this, void 0, void 0, function* () {
          return this.donePromise;
        });
        this.abort = (reason) => {
          if (!this.streamClosed) {
            this.abortController.abort(reason);
          }
        };
        this.endpointId = endpointId;
        this.config = config;
        this.url = (_a = options.url) !== null && _a !== void 0 ? _a : (0, request_1.buildUrl)(endpointId, {
          path: "/stream",
          query: options.queryParams
        });
        this.options = options;
        this.donePromise = new Promise((resolve, reject) => {
          if (this.streamClosed) {
            reject(new response_1.ApiError({
              message: "Streaming connection is already closed.",
              status: 400,
              body: void 0
            }));
          }
          this.signal.addEventListener("abort", () => {
            var _a2;
            resolve((_a2 = this.currentData) !== null && _a2 !== void 0 ? _a2 : {});
          });
          this.on("done", (data) => {
            this.streamClosed = true;
            resolve(data);
          });
          this.on("error", (error) => {
            this.streamClosed = true;
            reject(error);
          });
        });
        if (options.signal) {
          options.signal.addEventListener("abort", () => {
            this.abortController.abort();
          });
        }
        this.start().catch(this.handleError);
      }
      [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
          let running = true;
          const stopAsyncIterator = () => running = false;
          this.on("error", stopAsyncIterator);
          this.on("done", stopAsyncIterator);
          while (running || this.buffer.length > 0) {
            const data = this.buffer.shift();
            if (data) {
              yield yield __await(data);
            }
            yield __await(new Promise((resolve) => setTimeout(resolve, 16)));
          }
        });
      }
      /**
       * Gets the `AbortSignal` instance that can be used to listen for abort events.
       *
       * **Note:** this signal is internal to the `FalStream` instance. If you pass your
       * own abort signal, the `FalStream` will listen to it and abort it appropriately.
       *
       * @returns the `AbortSignal` instance.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal
       */
      get signal() {
        return this.abortController.signal;
      }
    };
    exports.FalStream = FalStream;
    function createStreamingClient({ config, storage }) {
      return {
        stream(endpointId, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const input = options.input ? yield storage.transformInput(options.input) : void 0;
            return new FalStream(endpointId, config, Object.assign(Object.assign({}, options), { input }));
          });
        }
      };
    }
  }
});

// node_modules/@fal-ai/client/src/queue.js
var require_queue = __commonJS({
  "node_modules/@fal-ai/client/src/queue.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createQueueClient = void 0;
    var request_1 = require_request();
    var response_1 = require_response();
    var streaming_1 = require_streaming();
    var utils_1 = require_utils();
    var DEFAULT_POLL_INTERVAL = 500;
    var createQueueClient = ({ config, storage }) => {
      const ref = {
        submit(endpointId, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const { webhookUrl, priority } = options, runOptions = __rest(options, ["webhookUrl", "priority"]);
            const input = options.input ? yield storage.transformInput(options.input) : void 0;
            return (0, request_1.dispatchRequest)({
              method: options.method,
              targetUrl: (0, request_1.buildUrl)(endpointId, Object.assign(Object.assign({}, runOptions), { subdomain: "queue", query: webhookUrl ? { fal_webhook: webhookUrl } : void 0 })),
              headers: {
                "x-fal-queue-priority": priority !== null && priority !== void 0 ? priority : "normal"
              },
              input,
              config,
              options: {
                signal: options.abortSignal
              }
            });
          });
        },
        status(endpointId_1, _a) {
          return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, logs = false, abortSignal }) {
            const appId = (0, utils_1.parseEndpointId)(endpointId);
            const prefix = appId.namespace ? `${appId.namespace}/` : "";
            return (0, request_1.dispatchRequest)({
              method: "get",
              targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {
                subdomain: "queue",
                query: { logs: logs ? "1" : "0" },
                path: `/requests/${requestId}/status`
              }),
              config,
              options: {
                signal: abortSignal
              }
            });
          });
        },
        streamStatus(endpointId_1, _a) {
          return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, logs = false, connectionMode }) {
            const appId = (0, utils_1.parseEndpointId)(endpointId);
            const prefix = appId.namespace ? `${appId.namespace}/` : "";
            const queryParams = {
              logs: logs ? "1" : "0"
            };
            const url = (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {
              subdomain: "queue",
              path: `/requests/${requestId}/status/stream`,
              query: queryParams
            });
            return new streaming_1.FalStream(endpointId, config, {
              url,
              method: "get",
              connectionMode,
              queryParams
            });
          });
        },
        subscribeToStatus(endpointId, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const requestId = options.requestId;
            const timeout = options.timeout;
            let timeoutId = void 0;
            const handleCancelError = () => {
            };
            if (options.mode === "streaming") {
              const status = yield ref.streamStatus(endpointId, {
                requestId,
                logs: options.logs,
                connectionMode: "connectionMode" in options ? options.connectionMode : void 0
              });
              const logs = [];
              if (timeout) {
                timeoutId = setTimeout(() => {
                  status.abort();
                  ref.cancel(endpointId, { requestId }).catch(handleCancelError);
                  throw new Error(`Client timed out waiting for the request to complete after ${timeout}ms`);
                }, timeout);
              }
              status.on("data", (data) => {
                if (options.onQueueUpdate) {
                  if ("logs" in data && Array.isArray(data.logs) && data.logs.length > 0) {
                    logs.push(...data.logs);
                  }
                  options.onQueueUpdate("logs" in data ? Object.assign(Object.assign({}, data), { logs }) : data);
                }
              });
              const doneStatus = yield status.done();
              if (timeoutId) {
                clearTimeout(timeoutId);
              }
              return doneStatus;
            }
            return new Promise((resolve, reject) => {
              var _a;
              let pollingTimeoutId;
              const pollInterval = "pollInterval" in options && typeof options.pollInterval === "number" ? (_a = options.pollInterval) !== null && _a !== void 0 ? _a : DEFAULT_POLL_INTERVAL : DEFAULT_POLL_INTERVAL;
              const clearScheduledTasks = () => {
                if (timeoutId) {
                  clearTimeout(timeoutId);
                }
                if (pollingTimeoutId) {
                  clearTimeout(pollingTimeoutId);
                }
              };
              if (timeout) {
                timeoutId = setTimeout(() => {
                  clearScheduledTasks();
                  ref.cancel(endpointId, { requestId }).catch(handleCancelError);
                  reject(new Error(`Client timed out waiting for the request to complete after ${timeout}ms`));
                }, timeout);
              }
              const poll = () => __awaiter(this, void 0, void 0, function* () {
                var _a2;
                try {
                  const requestStatus = yield ref.status(endpointId, {
                    requestId,
                    logs: (_a2 = options.logs) !== null && _a2 !== void 0 ? _a2 : false,
                    abortSignal: options.abortSignal
                  });
                  if (options.onQueueUpdate) {
                    options.onQueueUpdate(requestStatus);
                  }
                  if (requestStatus.status === "COMPLETED") {
                    clearScheduledTasks();
                    resolve(requestStatus);
                    return;
                  }
                  pollingTimeoutId = setTimeout(poll, pollInterval);
                } catch (error) {
                  clearScheduledTasks();
                  reject(error);
                }
              });
              poll().catch(reject);
            });
          });
        },
        result(endpointId_1, _a) {
          return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, abortSignal }) {
            const appId = (0, utils_1.parseEndpointId)(endpointId);
            const prefix = appId.namespace ? `${appId.namespace}/` : "";
            return (0, request_1.dispatchRequest)({
              method: "get",
              targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {
                subdomain: "queue",
                path: `/requests/${requestId}`
              }),
              config: Object.assign(Object.assign({}, config), { responseHandler: response_1.resultResponseHandler }),
              options: {
                signal: abortSignal
              }
            });
          });
        },
        cancel(endpointId_1, _a) {
          return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, abortSignal }) {
            const appId = (0, utils_1.parseEndpointId)(endpointId);
            const prefix = appId.namespace ? `${appId.namespace}/` : "";
            yield (0, request_1.dispatchRequest)({
              method: "put",
              targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {
                subdomain: "queue",
                path: `/requests/${requestId}/cancel`
              }),
              config,
              options: {
                signal: abortSignal
              }
            });
          });
        }
      };
      return ref;
    };
    exports.createQueueClient = createQueueClient;
  }
});

// node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs
function utf8Count(str) {
  const strLength = str.length;
  let byteLength = 0;
  let pos = 0;
  while (pos < strLength) {
    let value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      byteLength++;
      continue;
    } else if ((value & 4294965248) === 0) {
      byteLength += 2;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          const extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        byteLength += 3;
      } else {
        byteLength += 4;
      }
    }
  }
  return byteLength;
}
function utf8EncodeJs(str, output, outputOffset) {
  const strLength = str.length;
  let offset = outputOffset;
  let pos = 0;
  while (pos < strLength) {
    let value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      output[offset++] = value;
      continue;
    } else if ((value & 4294965248) === 0) {
      output[offset++] = value >> 6 & 31 | 192;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          const extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        output[offset++] = value >> 12 & 15 | 224;
        output[offset++] = value >> 6 & 63 | 128;
      } else {
        output[offset++] = value >> 18 & 7 | 240;
        output[offset++] = value >> 12 & 63 | 128;
        output[offset++] = value >> 6 & 63 | 128;
      }
    }
    output[offset++] = value & 63 | 128;
  }
}
function utf8EncodeTE(str, output, outputOffset) {
  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}
function utf8Encode(str, output, outputOffset) {
  if (str.length > TEXT_ENCODER_THRESHOLD) {
    utf8EncodeTE(str, output, outputOffset);
  } else {
    utf8EncodeJs(str, output, outputOffset);
  }
}
function utf8DecodeJs(bytes, inputOffset, byteLength) {
  let offset = inputOffset;
  const end = offset + byteLength;
  const units = [];
  let result = "";
  while (offset < end) {
    const byte1 = bytes[offset++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = bytes[offset++] & 63;
      const byte3 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = bytes[offset++] & 63;
      const byte3 = bytes[offset++] & 63;
      const byte4 = bytes[offset++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= CHUNK_SIZE) {
      result += String.fromCharCode(...units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += String.fromCharCode(...units);
  }
  return result;
}
function utf8DecodeTD(bytes, inputOffset, byteLength) {
  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
  return sharedTextDecoder.decode(stringBytes);
}
function utf8Decode(bytes, inputOffset, byteLength) {
  if (byteLength > TEXT_DECODER_THRESHOLD) {
    return utf8DecodeTD(bytes, inputOffset, byteLength);
  } else {
    return utf8DecodeJs(bytes, inputOffset, byteLength);
  }
}
var sharedTextEncoder, TEXT_ENCODER_THRESHOLD, CHUNK_SIZE, sharedTextDecoder, TEXT_DECODER_THRESHOLD;
var init_utf8 = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs"() {
    sharedTextEncoder = new TextEncoder();
    TEXT_ENCODER_THRESHOLD = 50;
    CHUNK_SIZE = 4096;
    sharedTextDecoder = new TextDecoder();
    TEXT_DECODER_THRESHOLD = 200;
  }
});

// node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs
var ExtData;
var init_ExtData = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs"() {
    ExtData = class {
      constructor(type, data) {
        this.type = type;
        this.data = data;
      }
    };
  }
});

// node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs
var DecodeError;
var init_DecodeError = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs"() {
    DecodeError = class _DecodeError extends Error {
      constructor(message) {
        super(message);
        const proto = Object.create(_DecodeError.prototype);
        Object.setPrototypeOf(this, proto);
        Object.defineProperty(this, "name", {
          configurable: true,
          enumerable: false,
          value: _DecodeError.name
        });
      }
    };
  }
});

// node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs
function setUint64(view, offset, value) {
  const high = value / 4294967296;
  const low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value) {
  const high = Math.floor(value / 4294967296);
  const low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function getInt64(view, offset) {
  const high = view.getInt32(offset);
  const low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}
function getUint64(view, offset) {
  const high = view.getUint32(offset);
  const low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}
var UINT32_MAX;
var init_int = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs"() {
    UINT32_MAX = 4294967295;
  }
});

// node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs
function encodeTimeSpecToTimestamp({ sec, nsec }) {
  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
      const rv = new Uint8Array(4);
      const view = new DataView(rv.buffer);
      view.setUint32(0, sec);
      return rv;
    } else {
      const secHigh = sec / 4294967296;
      const secLow = sec & 4294967295;
      const rv = new Uint8Array(8);
      const view = new DataView(rv.buffer);
      view.setUint32(0, nsec << 2 | secHigh & 3);
      view.setUint32(4, secLow);
      return rv;
    }
  } else {
    const rv = new Uint8Array(12);
    const view = new DataView(rv.buffer);
    view.setUint32(0, nsec);
    setInt64(view, 4, sec);
    return rv;
  }
}
function encodeDateToTimeSpec(date) {
  const msec = date.getTime();
  const sec = Math.floor(msec / 1e3);
  const nsec = (msec - sec * 1e3) * 1e6;
  const nsecInSec = Math.floor(nsec / 1e9);
  return {
    sec: sec + nsecInSec,
    nsec: nsec - nsecInSec * 1e9
  };
}
function encodeTimestampExtension(object) {
  if (object instanceof Date) {
    const timeSpec = encodeDateToTimeSpec(object);
    return encodeTimeSpecToTimestamp(timeSpec);
  } else {
    return null;
  }
}
function decodeTimestampToTimeSpec(data) {
  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  switch (data.byteLength) {
    case 4: {
      const sec = view.getUint32(0);
      const nsec = 0;
      return { sec, nsec };
    }
    case 8: {
      const nsec30AndSecHigh2 = view.getUint32(0);
      const secLow32 = view.getUint32(4);
      const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
      const nsec = nsec30AndSecHigh2 >>> 2;
      return { sec, nsec };
    }
    case 12: {
      const sec = getInt64(view, 4);
      const nsec = view.getUint32(0);
      return { sec, nsec };
    }
    default:
      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
  }
}
function decodeTimestampExtension(data) {
  const timeSpec = decodeTimestampToTimeSpec(data);
  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var EXT_TIMESTAMP, TIMESTAMP32_MAX_SEC, TIMESTAMP64_MAX_SEC, timestampExtension;
var init_timestamp = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs"() {
    init_DecodeError();
    init_int();
    EXT_TIMESTAMP = -1;
    TIMESTAMP32_MAX_SEC = 4294967296 - 1;
    TIMESTAMP64_MAX_SEC = 17179869184 - 1;
    timestampExtension = {
      type: EXT_TIMESTAMP,
      encode: encodeTimestampExtension,
      decode: decodeTimestampExtension
    };
  }
});

// node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs
var ExtensionCodec;
var init_ExtensionCodec = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs"() {
    init_ExtData();
    init_timestamp();
    ExtensionCodec = class {
      constructor() {
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        this.encoders = [];
        this.decoders = [];
        this.register(timestampExtension);
      }
      register({ type, encode: encode2, decode: decode2 }) {
        if (type >= 0) {
          this.encoders[type] = encode2;
          this.decoders[type] = decode2;
        } else {
          const index = -1 - type;
          this.builtInEncoders[index] = encode2;
          this.builtInDecoders[index] = decode2;
        }
      }
      tryToEncode(object, context) {
        for (let i = 0; i < this.builtInEncoders.length; i++) {
          const encodeExt = this.builtInEncoders[i];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = -1 - i;
              return new ExtData(type, data);
            }
          }
        }
        for (let i = 0; i < this.encoders.length; i++) {
          const encodeExt = this.encoders[i];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = i;
              return new ExtData(type, data);
            }
          }
        }
        if (object instanceof ExtData) {
          return object;
        }
        return null;
      }
      decode(data, type, context) {
        const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
          return decodeExt(data, type, context);
        } else {
          return new ExtData(type, data);
        }
      }
    };
    ExtensionCodec.defaultCodec = new ExtensionCodec();
  }
});

// node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs
function isArrayBufferLike(buffer) {
  return buffer instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && buffer instanceof SharedArrayBuffer;
}
function ensureUint8Array(buffer) {
  if (buffer instanceof Uint8Array) {
    return buffer;
  } else if (ArrayBuffer.isView(buffer)) {
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  } else if (isArrayBufferLike(buffer)) {
    return new Uint8Array(buffer);
  } else {
    return Uint8Array.from(buffer);
  }
}
var init_typedArrays = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs"() {
  }
});

// node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs
var DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder;
var init_Encoder = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs"() {
    init_utf8();
    init_ExtensionCodec();
    init_int();
    init_typedArrays();
    DEFAULT_MAX_DEPTH = 100;
    DEFAULT_INITIAL_BUFFER_SIZE = 2048;
    Encoder = class _Encoder {
      constructor(options) {
        this.entered = false;
        this.extensionCodec = (options == null ? void 0 : options.extensionCodec) ?? ExtensionCodec.defaultCodec;
        this.context = options == null ? void 0 : options.context;
        this.useBigInt64 = (options == null ? void 0 : options.useBigInt64) ?? false;
        this.maxDepth = (options == null ? void 0 : options.maxDepth) ?? DEFAULT_MAX_DEPTH;
        this.initialBufferSize = (options == null ? void 0 : options.initialBufferSize) ?? DEFAULT_INITIAL_BUFFER_SIZE;
        this.sortKeys = (options == null ? void 0 : options.sortKeys) ?? false;
        this.forceFloat32 = (options == null ? void 0 : options.forceFloat32) ?? false;
        this.ignoreUndefined = (options == null ? void 0 : options.ignoreUndefined) ?? false;
        this.forceIntegerToFloat = (options == null ? void 0 : options.forceIntegerToFloat) ?? false;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
      }
      clone() {
        return new _Encoder({
          extensionCodec: this.extensionCodec,
          context: this.context,
          useBigInt64: this.useBigInt64,
          maxDepth: this.maxDepth,
          initialBufferSize: this.initialBufferSize,
          sortKeys: this.sortKeys,
          forceFloat32: this.forceFloat32,
          ignoreUndefined: this.ignoreUndefined,
          forceIntegerToFloat: this.forceIntegerToFloat
        });
      }
      reinitializeState() {
        this.pos = 0;
      }
      /**
       * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
       *
       * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
       */
      encodeSharedRef(object) {
        if (this.entered) {
          const instance = this.clone();
          return instance.encodeSharedRef(object);
        }
        try {
          this.entered = true;
          this.reinitializeState();
          this.doEncode(object, 1);
          return this.bytes.subarray(0, this.pos);
        } finally {
          this.entered = false;
        }
      }
      /**
       * @returns Encodes the object and returns a copy of the encoder's internal buffer.
       */
      encode(object) {
        if (this.entered) {
          const instance = this.clone();
          return instance.encode(object);
        }
        try {
          this.entered = true;
          this.reinitializeState();
          this.doEncode(object, 1);
          return this.bytes.slice(0, this.pos);
        } finally {
          this.entered = false;
        }
      }
      doEncode(object, depth) {
        if (depth > this.maxDepth) {
          throw new Error(`Too deep objects in depth ${depth}`);
        }
        if (object == null) {
          this.encodeNil();
        } else if (typeof object === "boolean") {
          this.encodeBoolean(object);
        } else if (typeof object === "number") {
          if (!this.forceIntegerToFloat) {
            this.encodeNumber(object);
          } else {
            this.encodeNumberAsFloat(object);
          }
        } else if (typeof object === "string") {
          this.encodeString(object);
        } else if (this.useBigInt64 && typeof object === "bigint") {
          this.encodeBigInt64(object);
        } else {
          this.encodeObject(object, depth);
        }
      }
      ensureBufferSizeToWrite(sizeToWrite) {
        const requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
          this.resizeBuffer(requiredSize * 2);
        }
      }
      resizeBuffer(newSize) {
        const newBuffer = new ArrayBuffer(newSize);
        const newBytes = new Uint8Array(newBuffer);
        const newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
      }
      encodeNil() {
        this.writeU8(192);
      }
      encodeBoolean(object) {
        if (object === false) {
          this.writeU8(194);
        } else {
          this.writeU8(195);
        }
      }
      encodeNumber(object) {
        if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {
          if (object >= 0) {
            if (object < 128) {
              this.writeU8(object);
            } else if (object < 256) {
              this.writeU8(204);
              this.writeU8(object);
            } else if (object < 65536) {
              this.writeU8(205);
              this.writeU16(object);
            } else if (object < 4294967296) {
              this.writeU8(206);
              this.writeU32(object);
            } else if (!this.useBigInt64) {
              this.writeU8(207);
              this.writeU64(object);
            } else {
              this.encodeNumberAsFloat(object);
            }
          } else {
            if (object >= -32) {
              this.writeU8(224 | object + 32);
            } else if (object >= -128) {
              this.writeU8(208);
              this.writeI8(object);
            } else if (object >= -32768) {
              this.writeU8(209);
              this.writeI16(object);
            } else if (object >= -2147483648) {
              this.writeU8(210);
              this.writeI32(object);
            } else if (!this.useBigInt64) {
              this.writeU8(211);
              this.writeI64(object);
            } else {
              this.encodeNumberAsFloat(object);
            }
          }
        } else {
          this.encodeNumberAsFloat(object);
        }
      }
      encodeNumberAsFloat(object) {
        if (this.forceFloat32) {
          this.writeU8(202);
          this.writeF32(object);
        } else {
          this.writeU8(203);
          this.writeF64(object);
        }
      }
      encodeBigInt64(object) {
        if (object >= BigInt(0)) {
          this.writeU8(207);
          this.writeBigUint64(object);
        } else {
          this.writeU8(211);
          this.writeBigInt64(object);
        }
      }
      writeStringHeader(byteLength) {
        if (byteLength < 32) {
          this.writeU8(160 + byteLength);
        } else if (byteLength < 256) {
          this.writeU8(217);
          this.writeU8(byteLength);
        } else if (byteLength < 65536) {
          this.writeU8(218);
          this.writeU16(byteLength);
        } else if (byteLength < 4294967296) {
          this.writeU8(219);
          this.writeU32(byteLength);
        } else {
          throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
        }
      }
      encodeString(object) {
        const maxHeaderSize = 1 + 4;
        const byteLength = utf8Count(object);
        this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
        this.writeStringHeader(byteLength);
        utf8Encode(object, this.bytes, this.pos);
        this.pos += byteLength;
      }
      encodeObject(object, depth) {
        const ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
          this.encodeExtension(ext);
        } else if (Array.isArray(object)) {
          this.encodeArray(object, depth);
        } else if (ArrayBuffer.isView(object)) {
          this.encodeBinary(object);
        } else if (typeof object === "object") {
          this.encodeMap(object, depth);
        } else {
          throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
        }
      }
      encodeBinary(object) {
        const size = object.byteLength;
        if (size < 256) {
          this.writeU8(196);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(197);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(198);
          this.writeU32(size);
        } else {
          throw new Error(`Too large binary: ${size}`);
        }
        const bytes = ensureUint8Array(object);
        this.writeU8a(bytes);
      }
      encodeArray(object, depth) {
        const size = object.length;
        if (size < 16) {
          this.writeU8(144 + size);
        } else if (size < 65536) {
          this.writeU8(220);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(221);
          this.writeU32(size);
        } else {
          throw new Error(`Too large array: ${size}`);
        }
        for (const item of object) {
          this.doEncode(item, depth + 1);
        }
      }
      countWithoutUndefined(object, keys) {
        let count = 0;
        for (const key of keys) {
          if (object[key] !== void 0) {
            count++;
          }
        }
        return count;
      }
      encodeMap(object, depth) {
        const keys = Object.keys(object);
        if (this.sortKeys) {
          keys.sort();
        }
        const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
          this.writeU8(128 + size);
        } else if (size < 65536) {
          this.writeU8(222);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(223);
          this.writeU32(size);
        } else {
          throw new Error(`Too large map object: ${size}`);
        }
        for (const key of keys) {
          const value = object[key];
          if (!(this.ignoreUndefined && value === void 0)) {
            this.encodeString(key);
            this.doEncode(value, depth + 1);
          }
        }
      }
      encodeExtension(ext) {
        if (typeof ext.data === "function") {
          const data = ext.data(this.pos + 6);
          const size2 = data.length;
          if (size2 >= 4294967296) {
            throw new Error(`Too large extension object: ${size2}`);
          }
          this.writeU8(201);
          this.writeU32(size2);
          this.writeI8(ext.type);
          this.writeU8a(data);
          return;
        }
        const size = ext.data.length;
        if (size === 1) {
          this.writeU8(212);
        } else if (size === 2) {
          this.writeU8(213);
        } else if (size === 4) {
          this.writeU8(214);
        } else if (size === 8) {
          this.writeU8(215);
        } else if (size === 16) {
          this.writeU8(216);
        } else if (size < 256) {
          this.writeU8(199);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(200);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(201);
          this.writeU32(size);
        } else {
          throw new Error(`Too large extension object: ${size}`);
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
      }
      writeU8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
      }
      writeU8a(values) {
        const size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
      }
      writeI8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
      }
      writeU16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
      }
      writeI16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
      }
      writeU32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
      }
      writeI32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
      }
      writeF32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
      }
      writeF64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
      }
      writeU64(value) {
        this.ensureBufferSizeToWrite(8);
        setUint64(this.view, this.pos, value);
        this.pos += 8;
      }
      writeI64(value) {
        this.ensureBufferSizeToWrite(8);
        setInt64(this.view, this.pos, value);
        this.pos += 8;
      }
      writeBigUint64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setBigUint64(this.pos, value);
        this.pos += 8;
      }
      writeBigInt64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setBigInt64(this.pos, value);
        this.pos += 8;
      }
    };
  }
});

// node_modules/@msgpack/msgpack/dist.esm/encode.mjs
function encode(value, options) {
  const encoder = new Encoder(options);
  return encoder.encodeSharedRef(value);
}
var init_encode = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/encode.mjs"() {
    init_Encoder();
  }
});

// node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs
function prettyByte(byte) {
  return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
}
var init_prettyByte = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs"() {
  }
});

// node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs
var DEFAULT_MAX_KEY_LENGTH, DEFAULT_MAX_LENGTH_PER_KEY, CachedKeyDecoder;
var init_CachedKeyDecoder = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs"() {
    init_utf8();
    DEFAULT_MAX_KEY_LENGTH = 16;
    DEFAULT_MAX_LENGTH_PER_KEY = 16;
    CachedKeyDecoder = class {
      constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
        this.hit = 0;
        this.miss = 0;
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        this.caches = [];
        for (let i = 0; i < this.maxKeyLength; i++) {
          this.caches.push([]);
        }
      }
      canBeCached(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
      }
      find(bytes, inputOffset, byteLength) {
        const records = this.caches[byteLength - 1];
        FIND_CHUNK:
          for (const record of records) {
            const recordBytes = record.bytes;
            for (let j = 0; j < byteLength; j++) {
              if (recordBytes[j] !== bytes[inputOffset + j]) {
                continue FIND_CHUNK;
              }
            }
            return record.str;
          }
        return null;
      }
      store(bytes, value) {
        const records = this.caches[bytes.length - 1];
        const record = { bytes, str: value };
        if (records.length >= this.maxLengthPerKey) {
          records[Math.random() * records.length | 0] = record;
        } else {
          records.push(record);
        }
      }
      decode(bytes, inputOffset, byteLength) {
        const cachedValue = this.find(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
          this.hit++;
          return cachedValue;
        }
        this.miss++;
        const str = utf8DecodeJs(bytes, inputOffset, byteLength);
        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
      }
    };
  }
});

// node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs
var STATE_ARRAY, STATE_MAP_KEY, STATE_MAP_VALUE, mapKeyConverter, StackPool, HEAD_BYTE_REQUIRED, EMPTY_VIEW, EMPTY_BYTES, MORE_DATA, sharedCachedKeyDecoder, Decoder;
var init_Decoder = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs"() {
    init_prettyByte();
    init_ExtensionCodec();
    init_int();
    init_utf8();
    init_typedArrays();
    init_CachedKeyDecoder();
    init_DecodeError();
    STATE_ARRAY = "array";
    STATE_MAP_KEY = "map_key";
    STATE_MAP_VALUE = "map_value";
    mapKeyConverter = (key) => {
      if (typeof key === "string" || typeof key === "number") {
        return key;
      }
      throw new DecodeError("The type of key must be string or number but " + typeof key);
    };
    StackPool = class {
      constructor() {
        this.stack = [];
        this.stackHeadPosition = -1;
      }
      get length() {
        return this.stackHeadPosition + 1;
      }
      top() {
        return this.stack[this.stackHeadPosition];
      }
      pushArrayState(size) {
        const state = this.getUninitializedStateFromPool();
        state.type = STATE_ARRAY;
        state.position = 0;
        state.size = size;
        state.array = new Array(size);
      }
      pushMapState(size) {
        const state = this.getUninitializedStateFromPool();
        state.type = STATE_MAP_KEY;
        state.readCount = 0;
        state.size = size;
        state.map = {};
      }
      getUninitializedStateFromPool() {
        this.stackHeadPosition++;
        if (this.stackHeadPosition === this.stack.length) {
          const partialState = {
            type: void 0,
            size: 0,
            array: void 0,
            position: 0,
            readCount: 0,
            map: void 0,
            key: null
          };
          this.stack.push(partialState);
        }
        return this.stack[this.stackHeadPosition];
      }
      release(state) {
        const topStackState = this.stack[this.stackHeadPosition];
        if (topStackState !== state) {
          throw new Error("Invalid stack state. Released state is not on top of the stack.");
        }
        if (state.type === STATE_ARRAY) {
          const partialState = state;
          partialState.size = 0;
          partialState.array = void 0;
          partialState.position = 0;
          partialState.type = void 0;
        }
        if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {
          const partialState = state;
          partialState.size = 0;
          partialState.map = void 0;
          partialState.readCount = 0;
          partialState.type = void 0;
        }
        this.stackHeadPosition--;
      }
      reset() {
        this.stack.length = 0;
        this.stackHeadPosition = -1;
      }
    };
    HEAD_BYTE_REQUIRED = -1;
    EMPTY_VIEW = new DataView(new ArrayBuffer(0));
    EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
    try {
      EMPTY_VIEW.getInt8(0);
    } catch (e) {
      if (!(e instanceof RangeError)) {
        throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
      }
    }
    MORE_DATA = new RangeError("Insufficient data");
    sharedCachedKeyDecoder = new CachedKeyDecoder();
    Decoder = class _Decoder {
      constructor(options) {
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = new StackPool();
        this.entered = false;
        this.extensionCodec = (options == null ? void 0 : options.extensionCodec) ?? ExtensionCodec.defaultCodec;
        this.context = options == null ? void 0 : options.context;
        this.useBigInt64 = (options == null ? void 0 : options.useBigInt64) ?? false;
        this.rawStrings = (options == null ? void 0 : options.rawStrings) ?? false;
        this.maxStrLength = (options == null ? void 0 : options.maxStrLength) ?? UINT32_MAX;
        this.maxBinLength = (options == null ? void 0 : options.maxBinLength) ?? UINT32_MAX;
        this.maxArrayLength = (options == null ? void 0 : options.maxArrayLength) ?? UINT32_MAX;
        this.maxMapLength = (options == null ? void 0 : options.maxMapLength) ?? UINT32_MAX;
        this.maxExtLength = (options == null ? void 0 : options.maxExtLength) ?? UINT32_MAX;
        this.keyDecoder = (options == null ? void 0 : options.keyDecoder) !== void 0 ? options.keyDecoder : sharedCachedKeyDecoder;
        this.mapKeyConverter = (options == null ? void 0 : options.mapKeyConverter) ?? mapKeyConverter;
      }
      clone() {
        return new _Decoder({
          extensionCodec: this.extensionCodec,
          context: this.context,
          useBigInt64: this.useBigInt64,
          rawStrings: this.rawStrings,
          maxStrLength: this.maxStrLength,
          maxBinLength: this.maxBinLength,
          maxArrayLength: this.maxArrayLength,
          maxMapLength: this.maxMapLength,
          maxExtLength: this.maxExtLength,
          keyDecoder: this.keyDecoder
        });
      }
      reinitializeState() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.reset();
      }
      setBuffer(buffer) {
        const bytes = ensureUint8Array(buffer);
        this.bytes = bytes;
        this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        this.pos = 0;
      }
      appendBuffer(buffer) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
          this.setBuffer(buffer);
        } else {
          const remainingData = this.bytes.subarray(this.pos);
          const newData = ensureUint8Array(buffer);
          const newBuffer = new Uint8Array(remainingData.length + newData.length);
          newBuffer.set(remainingData);
          newBuffer.set(newData, remainingData.length);
          this.setBuffer(newBuffer);
        }
      }
      hasRemaining(size) {
        return this.view.byteLength - this.pos >= size;
      }
      createExtraByteError(posToShow) {
        const { view, pos } = this;
        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
      }
      /**
       * @throws {@link DecodeError}
       * @throws {@link RangeError}
       */
      decode(buffer) {
        if (this.entered) {
          const instance = this.clone();
          return instance.decode(buffer);
        }
        try {
          this.entered = true;
          this.reinitializeState();
          this.setBuffer(buffer);
          const object = this.doDecodeSync();
          if (this.hasRemaining(1)) {
            throw this.createExtraByteError(this.pos);
          }
          return object;
        } finally {
          this.entered = false;
        }
      }
      *decodeMulti(buffer) {
        if (this.entered) {
          const instance = this.clone();
          yield* instance.decodeMulti(buffer);
          return;
        }
        try {
          this.entered = true;
          this.reinitializeState();
          this.setBuffer(buffer);
          while (this.hasRemaining(1)) {
            yield this.doDecodeSync();
          }
        } finally {
          this.entered = false;
        }
      }
      async decodeAsync(stream) {
        if (this.entered) {
          const instance = this.clone();
          return instance.decodeAsync(stream);
        }
        try {
          this.entered = true;
          let decoded = false;
          let object;
          for await (const buffer of stream) {
            if (decoded) {
              this.entered = false;
              throw this.createExtraByteError(this.totalPos);
            }
            this.appendBuffer(buffer);
            try {
              object = this.doDecodeSync();
              decoded = true;
            } catch (e) {
              if (!(e instanceof RangeError)) {
                throw e;
              }
            }
            this.totalPos += this.pos;
          }
          if (decoded) {
            if (this.hasRemaining(1)) {
              throw this.createExtraByteError(this.totalPos);
            }
            return object;
          }
          const { headByte, pos, totalPos } = this;
          throw new RangeError(`Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`);
        } finally {
          this.entered = false;
        }
      }
      decodeArrayStream(stream) {
        return this.decodeMultiAsync(stream, true);
      }
      decodeStream(stream) {
        return this.decodeMultiAsync(stream, false);
      }
      async *decodeMultiAsync(stream, isArray) {
        if (this.entered) {
          const instance = this.clone();
          yield* instance.decodeMultiAsync(stream, isArray);
          return;
        }
        try {
          this.entered = true;
          let isArrayHeaderRequired = isArray;
          let arrayItemsLeft = -1;
          for await (const buffer of stream) {
            if (isArray && arrayItemsLeft === 0) {
              throw this.createExtraByteError(this.totalPos);
            }
            this.appendBuffer(buffer);
            if (isArrayHeaderRequired) {
              arrayItemsLeft = this.readArraySize();
              isArrayHeaderRequired = false;
              this.complete();
            }
            try {
              while (true) {
                yield this.doDecodeSync();
                if (--arrayItemsLeft === 0) {
                  break;
                }
              }
            } catch (e) {
              if (!(e instanceof RangeError)) {
                throw e;
              }
            }
            this.totalPos += this.pos;
          }
        } finally {
          this.entered = false;
        }
      }
      doDecodeSync() {
        DECODE:
          while (true) {
            const headByte = this.readHeadByte();
            let object;
            if (headByte >= 224) {
              object = headByte - 256;
            } else if (headByte < 192) {
              if (headByte < 128) {
                object = headByte;
              } else if (headByte < 144) {
                const size = headByte - 128;
                if (size !== 0) {
                  this.pushMapState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = {};
                }
              } else if (headByte < 160) {
                const size = headByte - 144;
                if (size !== 0) {
                  this.pushArrayState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = [];
                }
              } else {
                const byteLength = headByte - 160;
                object = this.decodeString(byteLength, 0);
              }
            } else if (headByte === 192) {
              object = null;
            } else if (headByte === 194) {
              object = false;
            } else if (headByte === 195) {
              object = true;
            } else if (headByte === 202) {
              object = this.readF32();
            } else if (headByte === 203) {
              object = this.readF64();
            } else if (headByte === 204) {
              object = this.readU8();
            } else if (headByte === 205) {
              object = this.readU16();
            } else if (headByte === 206) {
              object = this.readU32();
            } else if (headByte === 207) {
              if (this.useBigInt64) {
                object = this.readU64AsBigInt();
              } else {
                object = this.readU64();
              }
            } else if (headByte === 208) {
              object = this.readI8();
            } else if (headByte === 209) {
              object = this.readI16();
            } else if (headByte === 210) {
              object = this.readI32();
            } else if (headByte === 211) {
              if (this.useBigInt64) {
                object = this.readI64AsBigInt();
              } else {
                object = this.readI64();
              }
            } else if (headByte === 217) {
              const byteLength = this.lookU8();
              object = this.decodeString(byteLength, 1);
            } else if (headByte === 218) {
              const byteLength = this.lookU16();
              object = this.decodeString(byteLength, 2);
            } else if (headByte === 219) {
              const byteLength = this.lookU32();
              object = this.decodeString(byteLength, 4);
            } else if (headByte === 220) {
              const size = this.readU16();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 221) {
              const size = this.readU32();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 222) {
              const size = this.readU16();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 223) {
              const size = this.readU32();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 196) {
              const size = this.lookU8();
              object = this.decodeBinary(size, 1);
            } else if (headByte === 197) {
              const size = this.lookU16();
              object = this.decodeBinary(size, 2);
            } else if (headByte === 198) {
              const size = this.lookU32();
              object = this.decodeBinary(size, 4);
            } else if (headByte === 212) {
              object = this.decodeExtension(1, 0);
            } else if (headByte === 213) {
              object = this.decodeExtension(2, 0);
            } else if (headByte === 214) {
              object = this.decodeExtension(4, 0);
            } else if (headByte === 215) {
              object = this.decodeExtension(8, 0);
            } else if (headByte === 216) {
              object = this.decodeExtension(16, 0);
            } else if (headByte === 199) {
              const size = this.lookU8();
              object = this.decodeExtension(size, 1);
            } else if (headByte === 200) {
              const size = this.lookU16();
              object = this.decodeExtension(size, 2);
            } else if (headByte === 201) {
              const size = this.lookU32();
              object = this.decodeExtension(size, 4);
            } else {
              throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);
            }
            this.complete();
            const stack = this.stack;
            while (stack.length > 0) {
              const state = stack.top();
              if (state.type === STATE_ARRAY) {
                state.array[state.position] = object;
                state.position++;
                if (state.position === state.size) {
                  object = state.array;
                  stack.release(state);
                } else {
                  continue DECODE;
                }
              } else if (state.type === STATE_MAP_KEY) {
                if (object === "__proto__") {
                  throw new DecodeError("The key __proto__ is not allowed");
                }
                state.key = this.mapKeyConverter(object);
                state.type = STATE_MAP_VALUE;
                continue DECODE;
              } else {
                state.map[state.key] = object;
                state.readCount++;
                if (state.readCount === state.size) {
                  object = state.map;
                  stack.release(state);
                } else {
                  state.key = null;
                  state.type = STATE_MAP_KEY;
                  continue DECODE;
                }
              }
            }
            return object;
          }
      }
      readHeadByte() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
          this.headByte = this.readU8();
        }
        return this.headByte;
      }
      complete() {
        this.headByte = HEAD_BYTE_REQUIRED;
      }
      readArraySize() {
        const headByte = this.readHeadByte();
        switch (headByte) {
          case 220:
            return this.readU16();
          case 221:
            return this.readU32();
          default: {
            if (headByte < 160) {
              return headByte - 144;
            } else {
              throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);
            }
          }
        }
      }
      pushMapState(size) {
        if (size > this.maxMapLength) {
          throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
        }
        this.stack.pushMapState(size);
      }
      pushArrayState(size) {
        if (size > this.maxArrayLength) {
          throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
        }
        this.stack.pushArrayState(size);
      }
      decodeString(byteLength, headerOffset) {
        if (!this.rawStrings || this.stateIsMapKey()) {
          return this.decodeUtf8String(byteLength, headerOffset);
        }
        return this.decodeBinary(byteLength, headerOffset);
      }
      /**
       * @throws {@link RangeError}
       */
      decodeUtf8String(byteLength, headerOffset) {
        var _a;
        if (byteLength > this.maxStrLength) {
          throw new DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
          throw MORE_DATA;
        }
        const offset = this.pos + headerOffset;
        let object;
        if (this.stateIsMapKey() && ((_a = this.keyDecoder) == null ? void 0 : _a.canBeCached(byteLength))) {
          object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        } else {
          object = utf8Decode(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
      }
      stateIsMapKey() {
        if (this.stack.length > 0) {
          const state = this.stack.top();
          return state.type === STATE_MAP_KEY;
        }
        return false;
      }
      /**
       * @throws {@link RangeError}
       */
      decodeBinary(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
          throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
          throw MORE_DATA;
        }
        const offset = this.pos + headOffset;
        const object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
      }
      decodeExtension(size, headOffset) {
        if (size > this.maxExtLength) {
          throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
        }
        const extType = this.view.getInt8(this.pos + headOffset);
        const data = this.decodeBinary(
          size,
          headOffset + 1
          /* extType */
        );
        return this.extensionCodec.decode(data, extType, this.context);
      }
      lookU8() {
        return this.view.getUint8(this.pos);
      }
      lookU16() {
        return this.view.getUint16(this.pos);
      }
      lookU32() {
        return this.view.getUint32(this.pos);
      }
      readU8() {
        const value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
      }
      readI8() {
        const value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
      }
      readU16() {
        const value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
      }
      readI16() {
        const value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
      }
      readU32() {
        const value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
      }
      readI32() {
        const value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
      }
      readU64() {
        const value = getUint64(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readI64() {
        const value = getInt64(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readU64AsBigInt() {
        const value = this.view.getBigUint64(this.pos);
        this.pos += 8;
        return value;
      }
      readI64AsBigInt() {
        const value = this.view.getBigInt64(this.pos);
        this.pos += 8;
        return value;
      }
      readF32() {
        const value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
      }
      readF64() {
        const value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
      }
    };
  }
});

// node_modules/@msgpack/msgpack/dist.esm/decode.mjs
function decode(buffer, options) {
  const decoder = new Decoder(options);
  return decoder.decode(buffer);
}
function decodeMulti(buffer, options) {
  const decoder = new Decoder(options);
  return decoder.decodeMulti(buffer);
}
var init_decode = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/decode.mjs"() {
    init_Decoder();
  }
});

// node_modules/@msgpack/msgpack/dist.esm/utils/stream.mjs
function isAsyncIterable(object) {
  return object[Symbol.asyncIterator] != null;
}
async function* asyncIterableFromStream(stream) {
  const reader = stream.getReader();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        return;
      }
      yield value;
    }
  } finally {
    reader.releaseLock();
  }
}
function ensureAsyncIterable(streamLike) {
  if (isAsyncIterable(streamLike)) {
    return streamLike;
  } else {
    return asyncIterableFromStream(streamLike);
  }
}
var init_stream = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/utils/stream.mjs"() {
  }
});

// node_modules/@msgpack/msgpack/dist.esm/decodeAsync.mjs
async function decodeAsync(streamLike, options) {
  const stream = ensureAsyncIterable(streamLike);
  const decoder = new Decoder(options);
  return decoder.decodeAsync(stream);
}
function decodeArrayStream(streamLike, options) {
  const stream = ensureAsyncIterable(streamLike);
  const decoder = new Decoder(options);
  return decoder.decodeArrayStream(stream);
}
function decodeMultiStream(streamLike, options) {
  const stream = ensureAsyncIterable(streamLike);
  const decoder = new Decoder(options);
  return decoder.decodeStream(stream);
}
var init_decodeAsync = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/decodeAsync.mjs"() {
    init_Decoder();
    init_stream();
  }
});

// node_modules/@msgpack/msgpack/dist.esm/index.mjs
var dist_exports = {};
__export(dist_exports, {
  DecodeError: () => DecodeError,
  Decoder: () => Decoder,
  EXT_TIMESTAMP: () => EXT_TIMESTAMP,
  Encoder: () => Encoder,
  ExtData: () => ExtData,
  ExtensionCodec: () => ExtensionCodec,
  decode: () => decode,
  decodeArrayStream: () => decodeArrayStream,
  decodeAsync: () => decodeAsync,
  decodeMulti: () => decodeMulti,
  decodeMultiStream: () => decodeMultiStream,
  decodeTimestampExtension: () => decodeTimestampExtension,
  decodeTimestampToTimeSpec: () => decodeTimestampToTimeSpec,
  encode: () => encode,
  encodeDateToTimeSpec: () => encodeDateToTimeSpec,
  encodeTimeSpecToTimestamp: () => encodeTimeSpecToTimestamp,
  encodeTimestampExtension: () => encodeTimestampExtension
});
var init_dist = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/index.mjs"() {
    init_encode();
    init_decode();
    init_decodeAsync();
    init_Decoder();
    init_DecodeError();
    init_Encoder();
    init_ExtensionCodec();
    init_ExtData();
    init_timestamp();
  }
});

// node_modules/robot3/dist/machine.js
var require_machine = __commonJS({
  "node_modules/robot3/dist/machine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function valueEnumerable(value) {
      return { enumerable: true, value };
    }
    function valueEnumerableWritable(value) {
      return { enumerable: true, writable: true, value };
    }
    var d = {};
    var truthy = () => true;
    var empty = () => ({});
    var identity = (a) => a;
    var callBoth = (par, fn, self, args) => par.apply(self, args) && fn.apply(self, args);
    var callForward = (par, fn, self, [a, b]) => fn.call(self, par.call(self, a, b), b);
    var create = (a, b) => Object.freeze(Object.create(a, b));
    function stack(fns, def, caller) {
      return fns.reduce((par, fn) => {
        return function(...args) {
          return caller(par, fn, this, args);
        };
      }, def);
    }
    function fnType(fn) {
      return create(this, { fn: valueEnumerable(fn) });
    }
    var reduceType = {};
    var reduce = fnType.bind(reduceType);
    var action = (fn) => reduce((ctx, ev) => !!~fn(ctx, ev) && ctx);
    var guardType = {};
    var guard = fnType.bind(guardType);
    function filter(Type, arr) {
      return arr.filter((value) => Type.isPrototypeOf(value));
    }
    function makeTransition(from, to, ...args) {
      let guards = stack(filter(guardType, args).map((t) => t.fn), truthy, callBoth);
      let reducers = stack(filter(reduceType, args).map((t) => t.fn), identity, callForward);
      return create(this, {
        from: valueEnumerable(from),
        to: valueEnumerable(to),
        guards: valueEnumerable(guards),
        reducers: valueEnumerable(reducers)
      });
    }
    var transitionType = {};
    var immediateType = {};
    var transition = makeTransition.bind(transitionType);
    var immediate = makeTransition.bind(immediateType, null);
    function enterImmediate(machine2, service2, event) {
      return transitionTo(service2, machine2, event, this.immediates) || machine2;
    }
    function transitionsToMap(transitions) {
      let m = /* @__PURE__ */ new Map();
      for (let t of transitions) {
        if (!m.has(t.from))
          m.set(t.from, []);
        m.get(t.from).push(t);
      }
      return m;
    }
    var stateType = { enter: identity };
    function state(...args) {
      let transitions = filter(transitionType, args);
      let immediates = filter(immediateType, args);
      let desc = {
        final: valueEnumerable(args.length === 0),
        transitions: valueEnumerable(transitionsToMap(transitions))
      };
      if (immediates.length) {
        desc.immediates = valueEnumerable(immediates);
        desc.enter = valueEnumerable(enterImmediate);
      }
      return create(stateType, desc);
    }
    var invokeFnType = {
      enter(machine2, service2, event) {
        let rn = this.fn.call(service2, service2.context, event);
        if (machine.isPrototypeOf(rn))
          return create(invokeMachineType, {
            machine: valueEnumerable(rn),
            transitions: valueEnumerable(this.transitions)
          }).enter(machine2, service2, event);
        rn.then((data) => service2.send({ type: "done", data })).catch((error) => service2.send({ type: "error", error }));
        return machine2;
      }
    };
    var invokeMachineType = {
      enter(machine2, service2, event) {
        service2.child = interpret(this.machine, (s) => {
          service2.onChange(s);
          if (service2.child == s && s.machine.state.value.final) {
            delete service2.child;
            service2.send({ type: "done", data: s.context });
          }
        }, service2.context, event);
        if (service2.child.machine.state.value.final) {
          let data = service2.child.context;
          delete service2.child;
          return transitionTo(service2, machine2, { type: "done", data }, this.transitions.get("done"));
        }
        return machine2;
      }
    };
    function invoke(fn, ...transitions) {
      let t = valueEnumerable(transitionsToMap(transitions));
      return machine.isPrototypeOf(fn) ? create(invokeMachineType, {
        machine: valueEnumerable(fn),
        transitions: t
      }) : create(invokeFnType, {
        fn: valueEnumerable(fn),
        transitions: t
      });
    }
    var machine = {
      get state() {
        return {
          name: this.current,
          value: this.states[this.current]
        };
      }
    };
    function createMachine(current, states, contextFn = empty) {
      if (typeof current !== "string") {
        contextFn = states || empty;
        states = current;
        current = Object.keys(states)[0];
      }
      if (d._create)
        d._create(current, states);
      return create(machine, {
        context: valueEnumerable(contextFn),
        current: valueEnumerable(current),
        states: valueEnumerable(states)
      });
    }
    function transitionTo(service2, machine2, fromEvent, candidates) {
      let { context } = service2;
      for (let { to, guards, reducers } of candidates) {
        if (guards(context, fromEvent)) {
          service2.context = reducers.call(service2, context, fromEvent);
          let original = machine2.original || machine2;
          let newMachine = create(original, {
            current: valueEnumerable(to),
            original: { value: original }
          });
          if (d._onEnter)
            d._onEnter(machine2, to, service2.context, context, fromEvent);
          let state2 = newMachine.state.value;
          return state2.enter(newMachine, service2, fromEvent);
        }
      }
    }
    function send(service2, event) {
      let eventName = event.type || event;
      let { machine: machine2 } = service2;
      let { value: state2, name: currentStateName } = machine2.state;
      if (state2.transitions.has(eventName)) {
        return transitionTo(service2, machine2, event, state2.transitions.get(eventName)) || machine2;
      } else {
        if (d._send)
          d._send(eventName, currentStateName);
      }
      return machine2;
    }
    var service = {
      send(event) {
        this.machine = send(this, event);
        this.onChange(this);
      }
    };
    function interpret(machine2, onChange, initialContext, event) {
      let s = Object.create(service, {
        machine: valueEnumerableWritable(machine2),
        context: valueEnumerableWritable(machine2.context(initialContext, event)),
        onChange: valueEnumerable(onChange)
      });
      s.send = s.send.bind(s);
      s.machine = s.machine.state.value.enter(s.machine, s, event);
      return s;
    }
    exports.action = action;
    exports.createMachine = createMachine;
    exports.d = d;
    exports.guard = guard;
    exports.immediate = immediate;
    exports.interpret = interpret;
    exports.invoke = invoke;
    exports.reduce = reduce;
    exports.state = state;
    exports.transition = transition;
  }
});

// node_modules/@fal-ai/client/src/realtime.js
var require_realtime = __commonJS({
  "node_modules/@fal-ai/client/src/realtime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRealtimeClient = createRealtimeClient;
    var msgpack_1 = (init_dist(), __toCommonJS(dist_exports));
    var robot3_1 = require_machine();
    var auth_1 = require_auth();
    var response_1 = require_response();
    var runtime_1 = require_runtime();
    var utils_1 = require_utils();
    var initialState = () => ({
      enqueuedMessage: void 0
    });
    function hasToken(context) {
      return context.token !== void 0;
    }
    function noToken(context) {
      return !hasToken(context);
    }
    function enqueueMessage(context, event) {
      return Object.assign(Object.assign({}, context), { enqueuedMessage: event.message });
    }
    function closeConnection(context) {
      if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {
        context.websocket.close();
      }
      return Object.assign(Object.assign({}, context), { websocket: void 0 });
    }
    function sendMessage(context, event) {
      if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {
        if (event.message instanceof Uint8Array) {
          context.websocket.send(event.message);
        } else {
          context.websocket.send((0, msgpack_1.encode)(event.message));
        }
        return Object.assign(Object.assign({}, context), { enqueuedMessage: void 0 });
      }
      return Object.assign(Object.assign({}, context), { enqueuedMessage: event.message });
    }
    function expireToken(context) {
      return Object.assign(Object.assign({}, context), { token: void 0 });
    }
    function setToken(context, event) {
      return Object.assign(Object.assign({}, context), { token: event.token });
    }
    function connectionEstablished(context, event) {
      return Object.assign(Object.assign({}, context), { websocket: event.websocket });
    }
    var connectionStateMachine = (0, robot3_1.createMachine)("idle", {
      idle: (0, robot3_1.state)((0, robot3_1.transition)("send", "connecting", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)("expireToken", "idle", (0, robot3_1.reduce)(expireToken)), (0, robot3_1.transition)("close", "idle", (0, robot3_1.reduce)(closeConnection))),
      connecting: (0, robot3_1.state)((0, robot3_1.transition)("connecting", "connecting"), (0, robot3_1.transition)("connected", "active", (0, robot3_1.reduce)(connectionEstablished)), (0, robot3_1.transition)("connectionClosed", "idle", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)("send", "connecting", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)("close", "idle", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.immediate)("authRequired", (0, robot3_1.guard)(noToken))),
      authRequired: (0, robot3_1.state)((0, robot3_1.transition)("initiateAuth", "authInProgress"), (0, robot3_1.transition)("send", "authRequired", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)("close", "idle", (0, robot3_1.reduce)(closeConnection))),
      authInProgress: (0, robot3_1.state)((0, robot3_1.transition)("authenticated", "connecting", (0, robot3_1.reduce)(setToken)), (0, robot3_1.transition)("unauthorized", "idle", (0, robot3_1.reduce)(expireToken), (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)("send", "authInProgress", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)("close", "idle", (0, robot3_1.reduce)(closeConnection))),
      active: (0, robot3_1.state)((0, robot3_1.transition)("send", "active", (0, robot3_1.reduce)(sendMessage)), (0, robot3_1.transition)("unauthorized", "idle", (0, robot3_1.reduce)(expireToken)), (0, robot3_1.transition)("connectionClosed", "idle", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)("close", "idle", (0, robot3_1.reduce)(closeConnection))),
      failed: (0, robot3_1.state)((0, robot3_1.transition)("send", "failed"), (0, robot3_1.transition)("close", "idle", (0, robot3_1.reduce)(closeConnection)))
    }, initialState);
    function buildRealtimeUrl(app, { token, maxBuffering }) {
      if (maxBuffering !== void 0 && (maxBuffering < 1 || maxBuffering > 60)) {
        throw new Error("The `maxBuffering` must be between 1 and 60 (inclusive)");
      }
      const queryParams = new URLSearchParams({
        fal_jwt_token: token
      });
      if (maxBuffering !== void 0) {
        queryParams.set("max_buffering", maxBuffering.toFixed(0));
      }
      const appId = (0, utils_1.ensureEndpointIdFormat)(app);
      return `wss://fal.run/${appId}/realtime?${queryParams.toString()}`;
    }
    var DEFAULT_THROTTLE_INTERVAL = 128;
    function isUnauthorizedError(message) {
      return message["status"] === "error" && message["error"] === "Unauthorized";
    }
    var WebSocketErrorCodes = {
      NORMAL_CLOSURE: 1e3,
      GOING_AWAY: 1001
    };
    var connectionCache = /* @__PURE__ */ new Map();
    var connectionCallbacks = /* @__PURE__ */ new Map();
    function reuseInterpreter(key, throttleInterval, onChange) {
      if (!connectionCache.has(key)) {
        const machine = (0, robot3_1.interpret)(connectionStateMachine, onChange);
        connectionCache.set(key, Object.assign(Object.assign({}, machine), { throttledSend: throttleInterval > 0 ? (0, utils_1.throttle)(machine.send, throttleInterval, true) : machine.send }));
      }
      return connectionCache.get(key);
    }
    var noop = () => {
    };
    var NoOpConnection = {
      send: noop,
      close: noop
    };
    function isSuccessfulResult(data) {
      return data.status !== "error" && data.type !== "x-fal-message" && !isFalErrorResult(data);
    }
    function isFalErrorResult(data) {
      return data.type === "x-fal-error";
    }
    function createRealtimeClient({ config }) {
      return {
        connect(app, handler) {
          const {
            // if running on React in the server, set clientOnly to true by default
            clientOnly = (0, utils_1.isReact)() && !(0, runtime_1.isBrowser)(),
            connectionKey = crypto.randomUUID(),
            maxBuffering,
            throttleInterval = DEFAULT_THROTTLE_INTERVAL
          } = handler;
          if (clientOnly && !(0, runtime_1.isBrowser)()) {
            return NoOpConnection;
          }
          let previousState;
          connectionCallbacks.set(connectionKey, {
            onError: handler.onError,
            onResult: handler.onResult
          });
          const getCallbacks = () => connectionCallbacks.get(connectionKey);
          const stateMachine = reuseInterpreter(connectionKey, throttleInterval, ({ context, machine, send: send2 }) => {
            const { enqueuedMessage, token } = context;
            if (machine.current === "active" && enqueuedMessage) {
              send2({ type: "send", message: enqueuedMessage });
            }
            if (machine.current === "authRequired" && token === void 0 && previousState !== machine.current) {
              send2({ type: "initiateAuth" });
              (0, auth_1.getTemporaryAuthToken)(app, config).then((token2) => {
                send2({ type: "authenticated", token: token2 });
                const tokenExpirationTimeout = Math.round(auth_1.TOKEN_EXPIRATION_SECONDS * 0.9 * 1e3);
                setTimeout(() => {
                  send2({ type: "expireToken" });
                }, tokenExpirationTimeout);
              }).catch((error) => {
                send2({ type: "unauthorized", error });
              });
            }
            if (machine.current === "connecting" && previousState !== machine.current && token !== void 0) {
              const ws = new WebSocket(buildRealtimeUrl(app, { token, maxBuffering }));
              ws.onopen = () => {
                send2({ type: "connected", websocket: ws });
              };
              ws.onclose = (event) => {
                if (event.code !== WebSocketErrorCodes.NORMAL_CLOSURE) {
                  const { onError = noop } = getCallbacks();
                  onError(new response_1.ApiError({
                    message: `Error closing the connection: ${event.reason}`,
                    status: event.code
                  }));
                }
                send2({ type: "connectionClosed", code: event.code });
              };
              ws.onerror = (event) => {
                const { onError = noop } = getCallbacks();
                onError(new response_1.ApiError({ message: "Unknown error", status: 500 }));
              };
              ws.onmessage = (event) => {
                const { onResult } = getCallbacks();
                if (event.data instanceof ArrayBuffer) {
                  const result = (0, msgpack_1.decode)(new Uint8Array(event.data));
                  onResult(result);
                  return;
                }
                if (event.data instanceof Uint8Array) {
                  const result = (0, msgpack_1.decode)(event.data);
                  onResult(result);
                  return;
                }
                if (event.data instanceof Blob) {
                  event.data.arrayBuffer().then((buffer) => {
                    const result = (0, msgpack_1.decode)(new Uint8Array(buffer));
                    onResult(result);
                  });
                  return;
                }
                const data = JSON.parse(event.data);
                if (isUnauthorizedError(data)) {
                  send2({
                    type: "unauthorized",
                    error: new Error("Unauthorized")
                  });
                  return;
                }
                if (isSuccessfulResult(data)) {
                  onResult(data);
                  return;
                }
                if (isFalErrorResult(data)) {
                  if (data.error === "TIMEOUT") {
                    return;
                  }
                  const { onError = noop } = getCallbacks();
                  onError(new response_1.ApiError({
                    message: `${data.error}: ${data.reason}`,
                    // TODO better error status code
                    status: 400,
                    body: data
                  }));
                  return;
                }
              };
            }
            previousState = machine.current;
          });
          const send = (input) => {
            stateMachine.throttledSend({
              type: "send",
              message: input
            });
          };
          const close = () => {
            stateMachine.send({ type: "close" });
          };
          return {
            send,
            close
          };
        }
      };
    }
  }
});

// node_modules/@fal-ai/client/src/storage.js
var require_storage = __commonJS({
  "node_modules/@fal-ai/client/src/storage.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createStorageClient = createStorageClient;
    var config_1 = require_config();
    var request_1 = require_request();
    var utils_1 = require_utils();
    function getExtensionFromContentType(contentType) {
      var _a;
      const [_, fileType] = contentType.split("/");
      return (_a = fileType.split(/[-;]/)[0]) !== null && _a !== void 0 ? _a : "bin";
    }
    function initiateUpload(file, config, contentType) {
      return __awaiter(this, void 0, void 0, function* () {
        const filename = file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;
        return yield (0, request_1.dispatchRequest)({
          method: "POST",
          // NOTE: We want to test V3 without making it the default at the API level
          targetUrl: `${(0, config_1.getRestApiUrl)()}/storage/upload/initiate?storage_type=fal-cdn-v3`,
          input: {
            content_type: contentType,
            file_name: filename
          },
          config
        });
      });
    }
    function initiateMultipartUpload(file, config, contentType) {
      return __awaiter(this, void 0, void 0, function* () {
        const filename = file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;
        return yield (0, request_1.dispatchRequest)({
          method: "POST",
          targetUrl: `${(0, config_1.getRestApiUrl)()}/storage/upload/initiate-multipart?storage_type=fal-cdn-v3`,
          input: {
            content_type: contentType,
            file_name: filename
          },
          config
        });
      });
    }
    function partUploadRetries(uploadUrl_1, chunk_1, config_2) {
      return __awaiter(this, arguments, void 0, function* (uploadUrl, chunk, config, tries = 3) {
        if (tries === 0) {
          throw new Error("Part upload failed, retries exhausted");
        }
        const { fetch: fetch2, responseHandler } = config;
        try {
          const response = yield fetch2(uploadUrl, {
            method: "PUT",
            body: chunk
          });
          return yield responseHandler(response);
        } catch (error) {
          return yield partUploadRetries(uploadUrl, chunk, config, tries - 1);
        }
      });
    }
    function multipartUpload(file, config) {
      return __awaiter(this, void 0, void 0, function* () {
        const { fetch: fetch2, responseHandler } = config;
        const contentType = file.type || "application/octet-stream";
        const { upload_url: uploadUrl, file_url: url } = yield initiateMultipartUpload(file, config, contentType);
        const chunkSize = 10 * 1024 * 1024;
        const chunks = Math.ceil(file.size / chunkSize);
        const parsedUrl = new URL(uploadUrl);
        const responses = [];
        for (let i = 0; i < chunks; i++) {
          const start = i * chunkSize;
          const end = Math.min(start + chunkSize, file.size);
          const chunk = file.slice(start, end);
          const partNumber = i + 1;
          const partUploadUrl = `${parsedUrl.origin}${parsedUrl.pathname}/${partNumber}${parsedUrl.search}`;
          responses.push(yield partUploadRetries(partUploadUrl, chunk, config));
        }
        const completeUrl = `${parsedUrl.origin}${parsedUrl.pathname}/complete${parsedUrl.search}`;
        const response = yield fetch2(completeUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            parts: responses.map((mpart) => ({
              partNumber: mpart.partNumber,
              etag: mpart.etag
            }))
          })
        });
        yield responseHandler(response);
        return url;
      });
    }
    function createStorageClient({ config }) {
      const ref = {
        upload: (file) => __awaiter(this, void 0, void 0, function* () {
          if (file.size > 90 * 1024 * 1024) {
            return yield multipartUpload(file, config);
          }
          const contentType = file.type || "application/octet-stream";
          const { fetch: fetch2, responseHandler } = config;
          const { upload_url: uploadUrl, file_url: url } = yield initiateUpload(file, config, contentType);
          const response = yield fetch2(uploadUrl, {
            method: "PUT",
            body: file,
            headers: {
              "Content-Type": file.type || "application/octet-stream"
            }
          });
          yield responseHandler(response);
          return url;
        }),
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        transformInput: (input) => __awaiter(this, void 0, void 0, function* () {
          if (Array.isArray(input)) {
            return Promise.all(input.map((item) => ref.transformInput(item)));
          } else if (input instanceof Blob) {
            return yield ref.upload(input);
          } else if ((0, utils_1.isPlainObject)(input)) {
            const inputObject = input;
            const promises = Object.entries(inputObject).map((_a) => __awaiter(this, [_a], void 0, function* ([key, value]) {
              return [key, yield ref.transformInput(value)];
            }));
            const results = yield Promise.all(promises);
            return Object.fromEntries(results);
          }
          return input;
        })
      };
      return ref;
    }
  }
});

// node_modules/@fal-ai/client/src/client.js
var require_client = __commonJS({
  "node_modules/@fal-ai/client/src/client.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFalClient = createFalClient;
    var config_1 = require_config();
    var queue_1 = require_queue();
    var realtime_1 = require_realtime();
    var request_1 = require_request();
    var response_1 = require_response();
    var storage_1 = require_storage();
    var streaming_1 = require_streaming();
    function createFalClient(userConfig = {}) {
      const config = (0, config_1.createConfig)(userConfig);
      const storage = (0, storage_1.createStorageClient)({ config });
      const queue = (0, queue_1.createQueueClient)({ config, storage });
      const streaming = (0, streaming_1.createStreamingClient)({ config, storage });
      const realtime = (0, realtime_1.createRealtimeClient)({ config });
      return {
        queue,
        realtime,
        storage,
        streaming,
        stream: streaming.stream,
        run(endpointId_1) {
          return __awaiter(this, arguments, void 0, function* (endpointId, options = {}) {
            const input = options.input ? yield storage.transformInput(options.input) : void 0;
            return (0, request_1.dispatchRequest)({
              method: options.method,
              targetUrl: (0, request_1.buildUrl)(endpointId, options),
              input,
              config: Object.assign(Object.assign({}, config), { responseHandler: response_1.resultResponseHandler }),
              options: {
                signal: options.abortSignal
              }
            });
          });
        },
        subscribe: (endpointId, options) => __awaiter(this, void 0, void 0, function* () {
          const { request_id: requestId } = yield queue.submit(endpointId, options);
          if (options.onEnqueue) {
            options.onEnqueue(requestId);
          }
          yield queue.subscribeToStatus(endpointId, Object.assign({ requestId }, options));
          return queue.result(endpointId, { requestId });
        })
      };
    }
  }
});

// node_modules/@fal-ai/client/src/types/common.js
var require_common = __commonJS({
  "node_modules/@fal-ai/client/src/types/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isQueueStatus = isQueueStatus;
    exports.isCompletedQueueStatus = isCompletedQueueStatus;
    function isQueueStatus(obj) {
      return obj && obj.status && obj.response_url;
    }
    function isCompletedQueueStatus(obj) {
      return isQueueStatus(obj) && obj.status === "COMPLETED";
    }
  }
});

// node_modules/@fal-ai/client/src/index.js
var require_src = __commonJS({
  "node_modules/@fal-ai/client/src/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fal = exports.parseEndpointId = exports.ValidationError = exports.ApiError = exports.withProxy = exports.withMiddleware = exports.createFalClient = void 0;
    var client_1 = require_client();
    var client_2 = require_client();
    Object.defineProperty(exports, "createFalClient", { enumerable: true, get: function() {
      return client_2.createFalClient;
    } });
    var middleware_1 = require_middleware();
    Object.defineProperty(exports, "withMiddleware", { enumerable: true, get: function() {
      return middleware_1.withMiddleware;
    } });
    Object.defineProperty(exports, "withProxy", { enumerable: true, get: function() {
      return middleware_1.withProxy;
    } });
    var response_1 = require_response();
    Object.defineProperty(exports, "ApiError", { enumerable: true, get: function() {
      return response_1.ApiError;
    } });
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return response_1.ValidationError;
    } });
    __exportStar(require_common(), exports);
    var utils_1 = require_utils();
    Object.defineProperty(exports, "parseEndpointId", { enumerable: true, get: function() {
      return utils_1.parseEndpointId;
    } });
    exports.fal = function createSingletonFalClient() {
      let currentInstance = (0, client_1.createFalClient)();
      return {
        config(config) {
          currentInstance = (0, client_1.createFalClient)(config);
        },
        get queue() {
          return currentInstance.queue;
        },
        get realtime() {
          return currentInstance.realtime;
        },
        get storage() {
          return currentInstance.storage;
        },
        get streaming() {
          return currentInstance.streaming;
        },
        run(id, options) {
          return currentInstance.run(id, options);
        },
        subscribe(endpointId, options) {
          return currentInstance.subscribe(endpointId, options);
        },
        stream(endpointId, options) {
          return currentInstance.stream(endpointId, options);
        }
      };
    }();
  }
});
export default require_src();
//# sourceMappingURL=@fal-ai_client.js.map
